<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Robotics Specialization: Aerial Robotics | Ziwei's Site</title><meta name=keywords content="Robotics"><meta name=description content="Controller design for quadrotors.  "><meta name=author content><link rel=canonical href=https://ziwei-jiang.github.io/projects/robotics_specialization/aerial_robotics/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.175f8a2522675f2652eb58ad47be19952cb91de9e66edc4b95bb19fff5546ef5.css integrity="sha256-F1+KJSJnXyZS61itR74ZlSy5HenmbtxLlbsZ//VUbvU=" rel="preload stylesheet" as=style><link rel=icon href=https://ziwei-jiang.github.io/img/abra_icon.png><link rel=icon type=image/png sizes=16x16 href=https://ziwei-jiang.github.io/img/abra_icon.png><link rel=icon type=image/png sizes=32x32 href=https://ziwei-jiang.github.io/img/abra_icon.png><link rel=apple-touch-icon href=https://ziwei-jiang.github.io/img/abra_icon.png><link rel=mask-icon href=https://ziwei-jiang.github.io/img/abra_icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ziwei-jiang.github.io/projects/robotics_specialization/aerial_robotics/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-H4P7KF2N8Z"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-H4P7KF2N8Z")}</script><meta property="og:url" content="https://ziwei-jiang.github.io/projects/robotics_specialization/aerial_robotics/"><meta property="og:site_name" content="Ziwei's Site"><meta property="og:title" content="Robotics Specialization: Aerial Robotics"><meta property="og:description" content="Controller design for quadrotors.  "><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="projects"><meta property="article:published_time" content="2016-02-15T11:30:03+00:00"><meta property="article:modified_time" content="2016-02-15T11:30:03+00:00"><meta property="article:tag" content="Robotics"><meta property="og:image" content="https://ziwei-jiang.github.io/projects/robotics_specialization/aerial_robotics/projects/robotics_specialization/imgs/course1/aerial_robot.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ziwei-jiang.github.io/projects/robotics_specialization/aerial_robotics/projects/robotics_specialization/imgs/course1/aerial_robot.png"><meta name=twitter:title content="Robotics Specialization: Aerial Robotics"><meta name=twitter:description content="Controller design for quadrotors.  "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Projects","item":"https://ziwei-jiang.github.io/projects/"},{"@type":"ListItem","position":2,"name":"Robotics Specialization: Aerial Robotics","item":"https://ziwei-jiang.github.io/projects/robotics_specialization/aerial_robotics/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Robotics Specialization: Aerial Robotics","name":"Robotics Specialization: Aerial Robotics","description":"Controller design for quadrotors.  ","keywords":["Robotics"],"articleBody":"Here are the assignments for the Robotics Specialization: Aerial Robotics offered by UPenn on Coursera.\nIn this course, we learned some basic ideas about autonomous robots and the design of quadrotors. There are three assignments in this course in which we learned to design a PD controller for a quadrotor in 1D, 2D, and 3D. The course provided quadrotor simulators to help with the experiment. The simulator uses MATLAB’s ODE solver, ode45, to simulate the behavior of the quadrotor and plt3 to visualize the state of the quadrotor at each time step.\n1D Quadrotor Control For the first part, we only consider the motion in $z$-axis as shown in the figure. Quadrotor's vertical motion The net force in the vertical direction is given by $$F=m\\ddot{z} = u - mg$$ where $u$ is the rotor thrusts. The dynamic of the quadrotor in the vertical direction can be described by the following differential equation $$\\ddot{z}= \\frac{u}{m}- g.$$\nWe can measure the current position and velocity of the quadrotor in the vertical direction. Then we can use these and desired position and velocity to calculate the errors $$e = z_{des} - z.$$\nThe control input for a PD controller is $$u=m(\\ddot{z}+ K_pe + K_d\\dot{e} +g)$$ By choosing proper values for proportional and derivative gain, we can make the quadrotor respond quickly to a step input. The result is as Quadrotor's response to step input 2D Quadrotor Control For the second part, we learned to control the quadrotor in the 2D plane, as shown in the following figure. Quadrotor's planar motion In the figure, $a_2, a_3$ denote the inertial frame, and $b_2, b_3$ denote the body frame. In this setup, we want to control the quadrotor’s elevation and roll angle with two inputs: the thrust force ($u_1$) and the moment ($u_2$). The thrust force is defined as the sum of the thrusts at each rotor $$u_1 = F_1+F_2,$$ and the moment is the difference between the thrusts of two rotors times the arm length of the quadrotor ($L$), $$u_2 = L(F_1 - F_2).$$\nSuppose we can measure the position, velocity, acceleration, and angular acceleration of the robot. Let $r=[y, z]^T$ denote the position vector of the quadrotor in the inertial frame, and $R$ be the rotation matrix that transforms vector components from the body frame to the inertial frame. $$ R = \\begin{bmatrix} \\cos(\\phi) \u0026 -\\sin(\\phi) \\\\ \\sin(\\phi) \u0026 \\cos(\\phi) \\end{bmatrix} $$ The net force in the $Y, Z$ direction is given by $$ m \\begin{bmatrix} \\ddot{y} \\\\ \\ddot{z} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ -mg \\end{bmatrix} + R\\begin{bmatrix} 0 \\\\ u_1 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ -mg \\end{bmatrix} + \\begin{bmatrix} -u_1 \\sin(\\phi) \\\\ u_1\\cos(\\phi)\\end{bmatrix}.$$ The angular acceleration is given by $$ I_{xx}\\ddot{\\phi} = L(F_1 - F_2) = u_2.$$ Therefore, the system model is given by $$\\begin{bmatrix} \\ddot{y} \\\\ \\ddot{z} \\\\ \\ddot{\\phi} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ -g \\\\ 0 \\end{bmatrix} + \\begin{bmatrix} -\\frac{1}{m} \\sin(\\phi) \u0026 0 \\\\ \\frac{1}{m} \\cos(\\phi) \u0026 0 \\\\ 0 \u0026 \\frac{1}{I_{xx}}\\end{bmatrix} \\begin{bmatrix} u_1 \\\\ u_2\\end{bmatrix}.$$\nThe dynamic model of the quadrotor is nonlinear, so we need to linearize the equation of motions in order to apply the PD controller. For the quadrotor, the equilibrium point is the configuration at any position $(y^{(t)}, z^{(t)})$ with zero roll angle; and the thrust force is equal to the gravity $mg$. So we have $y^{(t)}, z^{(t)}, \\phi^{(t)}=0, u_1^{(t)} = mg, u_2^{(t)} = 0$. By the first-order Taylor approximation, we have $\\sin(\\phi^{(t)})\\approx 0, \\cos(\\phi^{(t)}) \\approx 1$. Thus the above system model can be written as $$\\begin{bmatrix} \\ddot{y} \\\\ \\ddot{z} \\\\ \\ddot{\\phi} \\end{bmatrix} = \\begin{bmatrix} -g\\phi \\\\ -g + \\frac{u_1}{m} \\\\ \\frac{u_2}{I_{xx}} \\end{bmatrix}, $$ and $$ \\begin{bmatrix} u_1 \\\\ u_2 \\\\ \\phi \\end{bmatrix} = \\begin{bmatrix} m(\\ddot{z} +g) \\\\ I_{xx}\\ddot{\\phi} \\\\ -\\frac{\\ddot{y}}{g} \\end{bmatrix}. $$\nLet $s$ denotes the state variable $(y$, $z$ or $\\phi)$ and $s_T(t)$ be the desired state variable at time $t$. Define the position and velocity errors as $$\\begin{bmatrix} e \\\\ \\dot{e} \\end{bmatrix} = \\begin{bmatrix} s_T(t) - s \\\\ \\dot s_T(t) - \\dot{s}\\end{bmatrix}.$$ The error should satisfy the following differential equation, $$ (\\ddot r_T(t) - \\ddot{r}) + K_d\\dot{e} + K_pe = 0. $$ So the commanded acceleration of the state can be expressed as $$ \\ddot{r} = \\ddot r_T(t) + K_d\\dot{e}+ K_pe . $$ The input can be expressed as $$ \\begin{bmatrix} u_1 \\\\ u_2 \\\\ \\phi \\end{bmatrix} = \\begin{bmatrix} m(\\ddot z_T(t) + K_{d,z}(\\dot z_T(t)-\\dot z)+ K_{p,z}(z_T(t) - z) +g) \\\\ I_{xx}(\\ddot \\phi_T(t) + K_{d,\\phi}(\\dot \\phi_T(t)-\\dot \\phi)+ K_{p,\\phi}(\\phi_T(t) - \\phi)) \\\\ -\\frac{1}{g} (\\ddot y_T(t) + K_{d,y}(\\dot y_T(t)-\\dot y)+ K_{p,y}(y_T(t) - y))\\end{bmatrix} .$$ The resulting controller is shown below. 2D trajectory 3D Quadrotor Control The last part of this course involves controlling the quadrotor in the 3D world coordinates. To represent the state of the quadrotor, we use rotation matrix $Z-X-Y$ with the axis of the world frame. The coordinate system is shown in the figure below, where $\\mathbf{a_i}$ represents the world frame, and $\\mathbf{b_i}$ represents the body frame. Quadrotor's 3D motion The rotation matrix for transform from $\\mathcal{A}$ to $\\mathcal{B}$ can be represented by the yaw angle $\\psi$, roll angle $\\phi$, and pitch angle $\\theta$:\n$$ ^\\mathcal{A}[R]_\\mathcal{B} = \\begin{bmatrix} \\cos\\psi\\cos\\theta-\\sin\\phi\\sin\\psi\\sin\\theta \u0026 -\\cos\\phi\\sin\\psi \u0026 \\cos\\psi\\sin\\theta + \\cos\\theta\\sin\\phi\\sin\\psi \\\\ \\cos\\theta\\sin\\psi + \\cos\\psi\\sin\\phi\\sin\\theta \u0026 \\cos\\phi\\cos\\psi \u0026 \\sin\\psi \\sin\\theta - \\cos\\psi\\cos\\theta\\sin\\phi \\\\ -\\cos\\phi\\sin\\theta \u0026 \\sin\\phi \u0026 \\cos\\phi\\cos\\theta \\end{bmatrix}.$$\nThe angular velocity of the quadrotor in the body frame $\\mathcal{B}$ can be represented by: $$^\\mathcal{A}\\omega_\\mathcal{B} = p\\mathbf{b_1} + q\\mathbf{b_2} + r\\mathbf{b_3},$$ where $p, q,$ and $r$ are related to the roll, pitch, and yaw angles as $$ \\begin{bmatrix} p\\\\ q\\\\ r\\\\ \\end{bmatrix} = \\begin{bmatrix} \\cos\\theta \u0026 0 \u0026-\\cos\\phi\\sin\\theta \\\\ 0 \u0026 1 \u0026 \\sin\\phi \\\\ \\sin\\theta \u0026 0 \u0026 \\cos\\phi\\cos\\theta \\end{bmatrix}\\begin{bmatrix} \\dot{\\phi} \\\\ \\dot{\\theta} \\\\ \\dot{\\psi} \\end{bmatrix}.$$\nNext we express the thrust force $F_i$ and moment $M_i$ that produced by each rotor with the angular speed $\\omega_i$, $$ F_i = k_F\\omega_i^2,$$ and $$ M_i = k_M\\omega_i^2.$$ The constant $k_F \\approx6.11 \\times 10^{-8} \\frac{N}{rpm^2}$, and $k_M \\approx 1.5\\times 10^{-9} \\frac{Nm}{rpm^2}$.\nThen we can relate the force produced by rotors with the quadrotor motion with Newton’s equation of motion\n$$m\\mathbf{\\ddot{r}} = \\begin{bmatrix} 0 \\\\ 0\\\\ -mg\\end{bmatrix} + \\mathbf{R} \\begin{bmatrix} 0\\\\ 0 \\\\ \\sum_{i=1}^4 F_i \\end{bmatrix}.$$\nFrom Euler’s equation of motion, we can relate the angular acceleration with the thrust force. Since the moment produced by each rotor is in the reverse direction of its rotation, the moment from the rotor 1 and 3 are in $\\mathbf{b_3}$ direction; the rotors 2 and 4 produce moment in $-\\mathbf{b_3}$ direction. Then by the Euler equation, we have\n$$ I\\begin{bmatrix} \\dot{p} \\\\ \\dot{q} \\\\ \\dot{r} \\end{bmatrix} = \\begin{bmatrix} L(F_2-F_4) \\\\ L(F_3-F_1) \\\\ M_1 -M_2+M3 -M_4 \\end{bmatrix} - \\begin{bmatrix} p\\\\ q\\\\ r\\end{bmatrix} \\times I \\begin{bmatrix} p \\\\ q \\\\ r \\end{bmatrix},$$ where $L$ is the distance from the rotor to the center of mass. Let $\\gamma = \\frac{k_M}{k_F}$, the above equation can be rewrite as $$ I\\begin{bmatrix} \\dot{p} \\\\ \\dot{q} \\\\ \\dot{r} \\end{bmatrix} = \\begin{bmatrix} 0 \u0026 L \u00260 \u0026-L \\\\ -L \u0026 0 \u0026 L \u0026 0 \\\\ \\gamma \u0026 -\\gamma \u0026 \\gamma \u0026 -\\gamma \\end{bmatrix} \\begin{bmatrix} F_1 \\\\ F_2 \\\\ F_3 \\\\ F_4 \\end{bmatrix} - \\begin{bmatrix} p \\\\ q \\\\ r \\end{bmatrix} \\times I \\begin{bmatrix} p \\\\ q \\\\ r \\end{bmatrix}$$\nIn this project, we consider two sets of input, the net thrust force $u_1 = \\sum_{i=1}^4 F_i $ and a vector $\\mathbf{u_2} = \\begin{bmatrix} L(F_2-F_4) \\\\ L(F_3-F_1) \\\\ M_1 - M_2 +M_3 -M_4 \\end{bmatrix}$, a function of thrust and moment. The controller is designed to perform hovering or trajectory following.\nControl loops for position and attitude As shown in the figure above, the outer loop controls the position from the error in the position vector and desired position. The inner loop controls the attitude of the quadrotor with the onboard accelerometers and gyros. The desired trajectory is represented by $$ \\mathbf{z}_{des} = \\begin{bmatrix} \\mathbf{r}_T(t) \\\\ \\psi_T(t) \\end{bmatrix}. $$\nThe PD controller for attitude control is $$ \\mathbf{u_2} = \\begin{bmatrix} k_{p,\\phi}(\\phi_{des} - \\phi)+ k_{d,\\phi}(p_{des}-p) \\\\ k_{q,\\theta} (\\theta_{des} - \\theta) + k_{d,\\theta}(q_{des} - q) \\\\ k_{r,\\phi}(\\psi_{des} - \\psi) + k_{d, psi}(r_{des}-r) \\end{bmatrix} $$\nSimilar to the 2D case, we linearize the equation of motions to apply the PD controller. The equilibrium point is the configuration at the position where the angular velocity is equal to zero; the pitch and roll angle are close to zero.\nLinearizing Newton’s equation, get $$ \\ddot{r_1} = g(\\Delta \\theta \\cos\\psi_0 + \\Delta\\phi\\sin\\psi_0)$$ $$ \\ddot{r_2} = g(\\Delta \\theta \\sin\\psi_0 - \\Delta\\phi\\cos\\psi_0)$$ $$\\ddot{r_3} = \\frac{1}{m}u_1 - g.$$\nLinearizing Euler’s equation, get\n$$ \\begin{bmatrix} \\dot{p} \\\\ \\dot{q} \\\\ \\dot{r}\\end{bmatrix} = I^{-1} \\begin{bmatrix} 0 \u0026 L \u0026 0 \u0026 -L \\\\ -L \u0026 0 \u0026 L \u0026 0 \\\\ \\gamma \u0026 -\\gamma \u0026 \\gamma \u0026 -\\gamma \\end{bmatrix} \\begin{bmatrix} F_1 \\\\ F_2 \\\\ F_3 \\\\ F_4 \\end{bmatrix}.$$\nThe following differential equation needs to be satisfied for the error exponentially goes to zero. $$ (\\ddot{r}_{i,T} - \\ddot{r} _{i,des}) + k _{d,i}(\\dot{r} _{i,T} - \\dot{r} _i)+ k _{p,i}(r _{i,T} - r_i) = 0$$\nFrom the above equation, we can derive the desired pitch and roll angles.\nThe 3D trajectory result is shown in the figures below.\n3D Helix trajectory Control loops for position and attitude (Images and codes are from Robotics : Aerial Robotics.)\n","wordCount":"1517","inLanguage":"en","image":"https://ziwei-jiang.github.io/projects/robotics_specialization/aerial_robotics/projects/robotics_specialization/imgs/course1/aerial_robot.png","datePublished":"2016-02-15T11:30:03Z","dateModified":"2016-02-15T11:30:03Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://ziwei-jiang.github.io/projects/robotics_specialization/aerial_robotics/"},"publisher":{"@type":"Organization","name":"Ziwei's Site","logo":{"@type":"ImageObject","url":"https://ziwei-jiang.github.io/img/abra_icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ziwei-jiang.github.io/ accesskey=h title="Ziwei Jiang 姜子维 (Alt + H)"><img src=https://ziwei-jiang.github.io/img/abra_icon.png alt aria-label=logo height=35>Ziwei Jiang 姜子维</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ziwei-jiang.github.io/about/ title=About><span>About</span></a></li><li><a href=https://ziwei-jiang.github.io/notes/ title=Notes><span>Notes</span></a></li><li><a href=https://ziwei-jiang.github.io/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://ziwei-jiang.github.io/publications/ title=Publications><span>Publications</span></a></li><li><a href=https://ziwei-jiang.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Robotics Specialization: Aerial Robotics</h1><div class=post-description>Controller design for quadrotors.</div><div class=post-meta><span title='2016-02-15 11:30:03 +0000 +0000'>February 15, 2016</span>&nbsp;·&nbsp;&nbsp;·&nbsp;<a href=/tags/robotics> Robotics</a></div></header><figure class=entry-cover1><img loading=lazy src=https://ziwei-jiang.github.io/projects/robotics_specialization/imgs/course1/aerial_robot.png alt><p></p></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1d-quadrotor-control aria-label="1D Quadrotor Control">1D Quadrotor Control</a></li><li><a href=#2d-quadrotor-control aria-label="2D Quadrotor Control">2D Quadrotor Control</a></li><li><a href=#3d-quadrotor-control aria-label="3D Quadrotor Control">3D Quadrotor Control</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>Here are the assignments for the <em>Robotics Specialization: Aerial Robotics</em> offered by UPenn on Coursera.</p><p>In this course, we learned some basic ideas about autonomous robots and the design of quadrotors. There are three assignments in this course in which we learned to design a PD controller for a quadrotor in 1D, 2D, and 3D.
The course provided quadrotor simulators to help with the experiment. The simulator uses MATLAB&rsquo;s ODE solver, ode45, to simulate the behavior of the quadrotor and plt3 to visualize the state of the quadrotor at each time step.</p><h1 id=1d-quadrotor-control>1D Quadrotor Control<a hidden class=anchor aria-hidden=true href=#1d-quadrotor-control>#</a></h1><p>For the first part, we only consider the motion in $z$-axis as shown in the figure.<figure class=align-center><img loading=lazy src=/projects/robotics_specialization/imgs/course1/1d_quad.png#center width=50%><figcaption>Quadrotor's vertical motion</figcaption></figure>The net force in the vertical direction is given by
$$F=m\ddot{z} = u - mg$$
where $u$ is the rotor thrusts.
The dynamic of the quadrotor in the vertical direction can be described by the following differential equation
$$\ddot{z}= \frac{u}{m}- g.$$</p><p>We can measure the current position and velocity of the quadrotor in the vertical direction. Then we can use these and desired position and velocity to calculate the errors
$$e = z_{des} - z.$$</p><p>The control input for a PD controller is
$$u=m(\ddot{z}+ K_pe + K_d\dot{e} +g)$$
By choosing proper values for proportional and derivative gain, we can make the quadrotor respond quickly to a step input. The result is as<figure class=align-center><img loading=lazy src=/projects/robotics_specialization/imgs/course1/1d_step.gif#center width=100%><figcaption>Quadrotor's response to step input</figcaption></figure></p><h1 id=2d-quadrotor-control>2D Quadrotor Control<a hidden class=anchor aria-hidden=true href=#2d-quadrotor-control>#</a></h1><p>For the second part, we learned to control the quadrotor in the 2D plane, as shown in the following figure.<figure class=align-center><img loading=lazy src=/projects/robotics_specialization/imgs/course1/2d_quad.png#center width=80%><figcaption>Quadrotor's planar motion</figcaption></figure>In the figure, $a_2, a_3$ denote the inertial frame, and $b_2, b_3$ denote the body frame.
In this setup, we want to control the quadrotor&rsquo;s elevation and roll angle with two inputs: the thrust force ($u_1$) and the moment ($u_2$).
The thrust force is defined as the sum of the thrusts at each rotor
$$u_1 = F_1+F_2,$$
and the moment is the difference between the thrusts of two rotors times the arm length of the quadrotor ($L$),
$$u_2 = L(F_1 - F_2).$$</p><p>Suppose we can measure the position, velocity, acceleration, and angular acceleration of the robot. Let $r=[y, z]^T$ denote the position vector of the quadrotor in the inertial frame, and $R$ be the rotation matrix that transforms vector components from the body frame to the inertial frame.
$$ R = \begin{bmatrix} \cos(\phi) & -\sin(\phi) \\ \sin(\phi) & \cos(\phi) \end{bmatrix} $$
The net force in the $Y, Z$ direction is given by
$$ m \begin{bmatrix} \ddot{y} \\ \ddot{z} \end{bmatrix} = \begin{bmatrix} 0 \\ -mg \end{bmatrix} + R\begin{bmatrix} 0 \\ u_1 \end{bmatrix} = \begin{bmatrix} 0 \\ -mg \end{bmatrix} + \begin{bmatrix} -u_1 \sin(\phi) \\ u_1\cos(\phi)\end{bmatrix}.$$
The angular acceleration is given by
$$ I_{xx}\ddot{\phi} = L(F_1 - F_2) = u_2.$$
Therefore, the system model is given by
$$\begin{bmatrix} \ddot{y} \\ \ddot{z} \\ \ddot{\phi} \end{bmatrix} = \begin{bmatrix} 0 \\ -g \\ 0 \end{bmatrix} + \begin{bmatrix} -\frac{1}{m} \sin(\phi) & 0 \\ \frac{1}{m} \cos(\phi) & 0 \\ 0 & \frac{1}{I_{xx}}\end{bmatrix} \begin{bmatrix} u_1 \\ u_2\end{bmatrix}.$$</p><p>The dynamic model of the quadrotor is nonlinear, so we need to linearize the equation of motions in order to apply the PD controller. For the quadrotor, the equilibrium point is the configuration at any position $(y^{(t)}, z^{(t)})$ with zero roll angle; and the thrust force is equal to the gravity $mg$. So we have $y^{(t)}, z^{(t)}, \phi^{(t)}=0, u_1^{(t)} = mg, u_2^{(t)} = 0$. By the first-order Taylor approximation, we have $\sin(\phi^{(t)})\approx 0, \cos(\phi^{(t)}) \approx 1$. Thus the above system model can be written as
$$\begin{bmatrix} \ddot{y} \\ \ddot{z} \\ \ddot{\phi} \end{bmatrix} = \begin{bmatrix} -g\phi \\ -g + \frac{u_1}{m} \\ \frac{u_2}{I_{xx}} \end{bmatrix}, $$
and
$$ \begin{bmatrix} u_1 \\ u_2 \\ \phi \end{bmatrix} = \begin{bmatrix} m(\ddot{z} +g) \\ I_{xx}\ddot{\phi} \\ -\frac{\ddot{y}}{g} \end{bmatrix}. $$</p><p>Let $s$ denotes the state variable $(y$, $z$ or $\phi)$ and $s_T(t)$ be the desired state variable at time $t$. Define the position and velocity errors as
$$\begin{bmatrix} e \\ \dot{e} \end{bmatrix} = \begin{bmatrix} s_T(t) - s \\ \dot s_T(t) - \dot{s}\end{bmatrix}.$$
The error should satisfy the following differential equation,
$$ (\ddot r_T(t) - \ddot{r}) + K_d\dot{e} + K_pe = 0. $$
So the commanded acceleration of the state can be expressed as
$$ \ddot{r} = \ddot r_T(t) + K_d\dot{e}+ K_pe . $$
The input can be expressed as
$$ \begin{bmatrix} u_1 \\ u_2 \\ \phi \end{bmatrix} = \begin{bmatrix} m(\ddot z_T(t) + K_{d,z}(\dot z_T(t)-\dot z)+ K_{p,z}(z_T(t) - z) +g) \\ I_{xx}(\ddot \phi_T(t) + K_{d,\phi}(\dot \phi_T(t)-\dot \phi)+ K_{p,\phi}(\phi_T(t) - \phi)) \\ -\frac{1}{g} (\ddot y_T(t) + K_{d,y}(\dot y_T(t)-\dot y)+ K_{p,y}(y_T(t) - y))\end{bmatrix} .$$
The resulting controller is shown below.<figure class=align-center><img loading=lazy src=/projects/robotics_specialization/imgs/course1/2d_traj.gif#center width=100%><figcaption>2D trajectory</figcaption></figure></p><h1 id=3d-quadrotor-control>3D Quadrotor Control<a hidden class=anchor aria-hidden=true href=#3d-quadrotor-control>#</a></h1><p>The last part of this course involves controlling the quadrotor in the 3D world coordinates. To represent the state of the quadrotor, we use rotation matrix $Z-X-Y$ with the axis of the world frame. The coordinate system is shown in the figure below, where $\mathbf{a_i}$ represents the world frame, and $\mathbf{b_i}$ represents the body frame.<figure class=align-center><img loading=lazy src=/projects/robotics_specialization/imgs/course1/3d_quad.png#center width=70%><figcaption>Quadrotor's 3D motion</figcaption></figure></p><p>The rotation matrix for transform from $\mathcal{A}$ to $\mathcal{B}$ can be represented by the yaw angle $\psi$, roll angle $\phi$, and pitch angle $\theta$:</p><p>$$ ^\mathcal{A}[R]_\mathcal{B} = \begin{bmatrix} \cos\psi\cos\theta-\sin\phi\sin\psi\sin\theta & -\cos\phi\sin\psi & \cos\psi\sin\theta + \cos\theta\sin\phi\sin\psi \\
\cos\theta\sin\psi + \cos\psi\sin\phi\sin\theta & \cos\phi\cos\psi & \sin\psi \sin\theta - \cos\psi\cos\theta\sin\phi \\ -\cos\phi\sin\theta & \sin\phi & \cos\phi\cos\theta \end{bmatrix}.$$</p><p>The angular velocity of the quadrotor in the body frame $\mathcal{B}$ can be represented by:
$$^\mathcal{A}\omega_\mathcal{B} = p\mathbf{b_1} + q\mathbf{b_2} + r\mathbf{b_3},$$
where $p, q,$ and $r$ are related to the roll, pitch, and yaw angles as
$$ \begin{bmatrix} p\\ q\\ r\\ \end{bmatrix} = \begin{bmatrix} \cos\theta & 0 &-\cos\phi\sin\theta \\ 0 & 1 & \sin\phi \\ \sin\theta & 0 & \cos\phi\cos\theta \end{bmatrix}\begin{bmatrix} \dot{\phi} \\ \dot{\theta} \\ \dot{\psi} \end{bmatrix}.$$</p><p>Next we express the thrust force $F_i$ and moment $M_i$ that produced by each rotor with the angular speed $\omega_i$,
$$ F_i = k_F\omega_i^2,$$
and
$$ M_i = k_M\omega_i^2.$$
The constant $k_F \approx6.11 \times 10^{-8} \frac{N}{rpm^2}$, and $k_M \approx 1.5\times 10^{-9} \frac{Nm}{rpm^2}$.</p><p>Then we can relate the force produced by rotors with the quadrotor motion with Newton&rsquo;s equation of motion</p><p>$$m\mathbf{\ddot{r}} = \begin{bmatrix} 0 \\ 0\\ -mg\end{bmatrix} + \mathbf{R} \begin{bmatrix} 0\\ 0 \\ \sum_{i=1}^4 F_i \end{bmatrix}.$$</p><p>From Euler&rsquo;s equation of motion, we can relate the angular acceleration with the thrust force. Since the moment produced by each rotor is in the reverse direction of its rotation, the moment from the rotor 1 and 3 are in $\mathbf{b_3}$ direction; the rotors 2 and 4 produce moment in $-\mathbf{b_3}$ direction. Then by the Euler equation, we have</p><p>$$ I\begin{bmatrix} \dot{p} \\ \dot{q} \\ \dot{r} \end{bmatrix} = \begin{bmatrix} L(F_2-F_4) \\ L(F_3-F_1) \\ M_1 -M_2+M3 -M_4 \end{bmatrix} - \begin{bmatrix} p\\ q\\ r\end{bmatrix} \times I \begin{bmatrix} p \\ q \\ r \end{bmatrix},$$
where $L$ is the distance from the rotor to the center of mass. Let $\gamma = \frac{k_M}{k_F}$, the above equation can be rewrite as
$$ I\begin{bmatrix} \dot{p} \\ \dot{q} \\ \dot{r} \end{bmatrix} = \begin{bmatrix} 0 & L &amp;0 &-L \\ -L & 0 & L & 0 \\ \gamma & -\gamma & \gamma & -\gamma \end{bmatrix} \begin{bmatrix} F_1 \\ F_2 \\ F_3 \\ F_4 \end{bmatrix} - \begin{bmatrix} p \\ q \\ r \end{bmatrix} \times I \begin{bmatrix} p \\ q \\ r \end{bmatrix}$$</p><p>In this project, we consider two sets of input, the net thrust force $u_1 = \sum_{i=1}^4 F_i $ and a vector $\mathbf{u_2} = \begin{bmatrix} L(F_2-F_4) \\ L(F_3-F_1) \\ M_1 - M_2 +M_3 -M_4 \end{bmatrix}$, a function of thrust and moment. The controller is designed to perform hovering or trajectory following.</p><figure class=align-center><img loading=lazy src=/projects/robotics_specialization/imgs/course1/control_loops.png#center width=90%><figcaption>Control loops for position and attitude</figcaption></figure><p>As shown in the figure above, the outer loop controls the position from the error in the position vector and desired position. The inner loop controls the attitude of the quadrotor with the onboard accelerometers and gyros. The desired trajectory is represented by
$$ \mathbf{z}_{des} = \begin{bmatrix} \mathbf{r}_T(t) \\ \psi_T(t) \end{bmatrix}. $$</p><p>The PD controller for attitude control is
$$ \mathbf{u_2} = \begin{bmatrix} k_{p,\phi}(\phi_{des} - \phi)+ k_{d,\phi}(p_{des}-p) \\ k_{q,\theta} (\theta_{des} - \theta) + k_{d,\theta}(q_{des} - q) \\
k_{r,\phi}(\psi_{des} - \psi) + k_{d, psi}(r_{des}-r) \end{bmatrix} $$</p><p>Similar to the 2D case, we linearize the equation of motions to apply the PD controller. The equilibrium point is the configuration at the position where the angular velocity is equal to zero; the pitch and roll angle are close to zero.</p><p>Linearizing Newton&rsquo;s equation, get
$$ \ddot{r_1} = g(\Delta \theta \cos\psi_0 + \Delta\phi\sin\psi_0)$$
$$ \ddot{r_2} = g(\Delta \theta \sin\psi_0 - \Delta\phi\cos\psi_0)$$
$$\ddot{r_3} = \frac{1}{m}u_1 - g.$$</p><p>Linearizing Euler&rsquo;s equation, get</p><p>$$ \begin{bmatrix} \dot{p} \\ \dot{q} \\ \dot{r}\end{bmatrix} = I^{-1} \begin{bmatrix} 0 & L & 0 & -L \\ -L & 0 & L & 0 \\ \gamma & -\gamma & \gamma & -\gamma \end{bmatrix} \begin{bmatrix} F_1 \\ F_2 \\ F_3 \\ F_4 \end{bmatrix}.$$</p><p>The following differential equation needs to be satisfied for the error exponentially goes to zero.
$$ (\ddot{r}_{i,T} - \ddot{r} _{i,des}) + k _{d,i}(\dot{r} _{i,T} - \dot{r} _i)+ k _{p,i}(r _{i,T} - r_i) = 0$$</p><p>From the above equation, we can derive the desired pitch and roll angles.</p><p>The 3D trajectory result is shown in the figures below.</p><figure class=align-center><img loading=lazy src=/projects/robotics_specialization/imgs/course1/3d_traj.gif#center width=70%><figcaption>3D Helix trajectory</figcaption></figure><figure class=align-center><img loading=lazy src=/projects/robotics_specialization/imgs/course1/3d_plots.png#center width=100%><figcaption>Control loops for position and attitude</figcaption></figure><p>(Images and codes are from <a href=https://www.coursera.org/learn/robotics-flight>Robotics : Aerial Robotics</a>.)</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ziwei-jiang.github.io/tags/robotics/>Robotics</a></li></ul><nav class=paginav><a class=prev href=https://ziwei-jiang.github.io/projects/robotics_specialization/computational_motion_planning/><span class=title>« Prev</span><br><span>Robotics Specialization: Computational Motion Planning</span>
</a><a class=next href=https://ziwei-jiang.github.io/notes/coming_soon/><span class=title>Next »</span><br><span>Notes</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ziwei-jiang.github.io/>Ziwei's Site</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>