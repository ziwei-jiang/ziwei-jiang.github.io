<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Robotics Specialization: Computational Motion Planning | Ziwei's Site</title><meta name=keywords content="Robotics"><meta name=description content="Motion and path planning for robots. "><meta name=author content><link rel=canonical href=https://ziwei-jiang.github.io/projects/robotics_specialization/computational_motion_planning/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.175f8a2522675f2652eb58ad47be19952cb91de9e66edc4b95bb19fff5546ef5.css integrity="sha256-F1+KJSJnXyZS61itR74ZlSy5HenmbtxLlbsZ//VUbvU=" rel="preload stylesheet" as=style><link rel=icon href=https://ziwei-jiang.github.io/img/abra_icon.png><link rel=icon type=image/png sizes=16x16 href=https://ziwei-jiang.github.io/img/abra_icon.png><link rel=icon type=image/png sizes=32x32 href=https://ziwei-jiang.github.io/img/abra_icon.png><link rel=apple-touch-icon href=https://ziwei-jiang.github.io/img/abra_icon.png><link rel=mask-icon href=https://ziwei-jiang.github.io/img/abra_icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ziwei-jiang.github.io/projects/robotics_specialization/computational_motion_planning/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-H4P7KF2N8Z"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-H4P7KF2N8Z")}</script><meta property="og:url" content="https://ziwei-jiang.github.io/projects/robotics_specialization/computational_motion_planning/"><meta property="og:site_name" content="Ziwei's Site"><meta property="og:title" content="Robotics Specialization: Computational Motion Planning"><meta property="og:description" content="Motion and path planning for robots. "><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="projects"><meta property="article:published_time" content="2016-03-15T11:30:03+00:00"><meta property="article:modified_time" content="2016-03-15T11:30:03+00:00"><meta property="article:tag" content="Robotics"><meta property="og:image" content="https://ziwei-jiang.github.io/projects/robotics_specialization/computational_motion_planning/projects/robotics_specialization/imgs/course2/motion_planning.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ziwei-jiang.github.io/projects/robotics_specialization/computational_motion_planning/projects/robotics_specialization/imgs/course2/motion_planning.png"><meta name=twitter:title content="Robotics Specialization: Computational Motion Planning"><meta name=twitter:description content="Motion and path planning for robots. "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Projects","item":"https://ziwei-jiang.github.io/projects/"},{"@type":"ListItem","position":2,"name":"Robotics Specialization: Computational Motion Planning","item":"https://ziwei-jiang.github.io/projects/robotics_specialization/computational_motion_planning/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Robotics Specialization: Computational Motion Planning","name":"Robotics Specialization: Computational Motion Planning","description":"Motion and path planning for robots. ","keywords":["Robotics"],"articleBody":"Here are the assignments for the Robotics Specialization: Computational Motion Planning offered by UPenn on Coursera.\nThis is the second course in the robotics specialization. Throughout this course, we have gained knowledge on different techniques for planning robot motions. These include graph-based methods, randomized planners, and artificial potential fields.\nGraph-based Methods Graph-based methods tackle the challenge of planning routes for robots in environments with discrete positions, such as grids. To address this problem, we can represent such scenarios as graphs, where nodes signify grid locations, and edges indicate the routes between neighboring grid cells. In this course, we learned and implemented two graph-based algorithms, Dijkstra and the A-Star algorithm.\nDijkstra Algorithm Dijkstra algorithm is a greedy algorithm for finding shortest path in weighted graphs. Invented by Dutch computer scientist Edsger W. Dijkstra in 1956, Dijkstra’s algorithm has a wide range of applications in computer science, from network routing protocols to GPS nevigation. The algorithm works by exploring all possible paths from a starting node to a target node, keeping track of the distance traveled along each path. It then selects the shortest path and marks it as the optimal route. Here is a pseudocode for the Dijkstra algorithm.\nstart_node start for each node v: v.dist = infinity start.dist = 0 list = [start] while list is not empty: current = node in list with smallest distance list.del(current) for n in current.neighbor: if n.dist \u003e current.dist + dist(n, current): n.dist = current.dist + dist(n, current) n.parent = current if n not in list: list.append(n) When the algorithm visits a node, it updates the distances to its neighbors based on the shortest path found so far. Since any new paths to the neighbors would have to go through the current node, the loop invariant is true after updating the distances to its neighbors. When the algorithm terminates, all nodes in the graph have been visited and the loop invariant holds for all nodes. Therefore, the algorithm has found the shortest path from the start node to all other nodes in the graph. With naive implementation, the Dijkstra algorithm has time complexity $\\mathcal{O}(|V|^2)$. Using priority queue, this can be reduced to $\\mathcal{O}((|V|+|E|)\\log(|V|))$.\nBelowing is a demo result of Dijkstra algorithm implemented in Matlab. The green and yellow block are the start and target position. The blue blocks are the nodes in the list. The red blocks are the nodes with the shortest path have been found and removed from the list. Dijkstra Algorithm The Dijkstra algorithm can be computationally expensive on large graphs. Since the algorithm treats all nodes equally and does not consider any heuristic information about the target node, it may explore unnecessary paths. This makes it less suitable for real-time applications.\nA-Star Algorithm To overcome these limitations, the A-Star algorithm was developed by Peter Hart, Nils Nilsson and Bertram Raphael of Stanford Research Institute in 1968. A-Star algorithm enhances Dijkstra’s algorithm by introducing a heuristic function, which provides an estimate of the remaining distance from a particular node to the target node.\nThe heuristic function needs to satisfy the two criteria:\n$H(goal) = 0$ For any $x,y\\in V$, $H(x)\\leq H(y) + d(x,y)$ By those two properties, for any node $v\\in V$, we have $$H(v) \\leq \\text{length of shortest path from v to goal}$$ So the heuristic function $H(v)$ is an underestimate for the distance between the node $v$ and the goal. With the heuristic function, the algorithm chooses the node that is most likely to be on the shortest path between start and goal node.\nHere is a pseudocode for the A-Star algorithm.\nstart_node start, goal_node goal for each node v: v.dist = infinity, v.f = infinity start.dist = 0, start.f = H(start) list = [start] while list is not empty: current = node in list with smallest f value list.del(current) if current == goal: return success for n in current.neighbor: if n.dist \u003e current.dist + dist(n, current): n.dist = current.dist + dist(n, current) n.f = n.g+H(n) n.parent = current if n not in list: list.append(n) Belowing is a demo result of A-Star algorithm implemented in Matlab. Dijkstra Algorithm Configuration Space Path Planning Motion planning in configuration space, often referred to as C-space, involves utilizing the C-space as a representation of the feasible motions available to a robot. The configuration space encapsulates all the possible configurations of the robot, including the positions and orientations of its individual components. In configuration space planning, this graph is created directly in the C-space, where each node corresponds to a valid robot configuration and edges represent feasible transitions between them. By navigating this graph, motion planning algorithms can explore the C-space to find collision-free paths for the robot, accounting for its kinematic and dynamic constraints.\nFor instance, in the case of a two-linked arm, the configuration space would capture all possible combinations of joint angles, allowing the planner to find optimal paths while avoiding collisions. Similarly, in the piano mover’s problem, where a robot needs to navigate through a cluttered environment to move a large object, configuration space planning enables the robot to consider the dimensions and orientations of both the robot and the object, resulting in more precise and accurate path planning. By leveraging the configuration space approach, motion planners can tackle a wide range of challenging scenarios, providing efficient and safe solutions for various robotic applications.\nSampling Methods In this assignment, we worked with a two-link robot arm and its configuration space. Our goal was to guide the robot arm from one configuration to another while avoiding obstacles in the workspace. We applied collision detection by representing the robot arm and obstacles as collections of triangles. We checked for intersections between these triangles, allowing us to determine if the robot arm would collide with any obstacles while navigating the workspace. In this example, the workspace and configuration space are shown in the following figure. Two link robot arm and its configuration space We used a freespace sampling method, where we sampled points in the 2-dimensional configuration space and determined whether they were in free space or obstacle space based on the results of the collision check. This allowed us to represent the configuration space obstacles and free space with 2D array and apply the Dijkstra algorithm on torus.\nMotion Planning in Free Space The Dijkstra’s algorithm can be slow in this case, particularly when dealing with a high-dimensional configuration space. To address this, we can employ the A-Star algorithm, which offers a more efficient alternative. The benefits of using the A-Star algorithm, compared to Dijkstra’s algorithm, are illustrated in the figure below.\nAfter finding the shortest path in the configuration space, the robot can proceed to execute the corresponding trajectory.\nSampling-based Methods Probabilistic Road Maps In the above example, we employ a simple approach of evenly discretizing the continuous configuration space and utilizing a graph-based method to determine the shortest path. However, both the Dijkstra and A-Star algorithms can become slow when dealing with a large searching dimension. This situation often arises in scenarios where the configuration space exhibits a high dimensionality. To address this challenge, an alternative method is by selecting points randomly from the configuration space instead of uniformly. By using a subset of these randomly sampled points to represent the free space, we can effectively compute the shortest path. This technique is commonly referred to as Probabilistic Road Maps(PRM). During each iteration of the algorithm, if the randomly sampled point falls in free space, we find k-nearest points according to some distance function. We then try to connect the sampled point to those points using a local planner, which checks if the line between two points is in free space. The pseudocode for the PRM algorithm is outlined below.\nRepeat n times: Randomly sample a point x in the configuration space if x is in free space: Find the k closest points to x according to the distance function Form a new edge if the connection from x to each point is a free path Although sampling-based methods are often effective in practice, it’s important to note that these algorithms are not considered complete. This means that there is a possibility of the algorithm failing to find a path, even if one exists. But we can say that as we continue sampling new points, the algorithm will eventually find a solution if a path to the goal exists. In other word, as the number of samples (n) approaches infinity, the probability of not finding a path approaches zero. This is known as probabilistically complete.\nHowever, this process could take a very long time in some cases. For instance, if we there is a narrow pathway to the goal, the algorithm will require a denser sampling to successfully discover the solution.\nRapidly Exploring Random Trees The Probabilistic Roadmap (PRM) algorithm offers the advantage of constructing a structure that represents the entire configuration space, allowing for easy adaptation to different starting and ending positions. However, there are scenarios where our focus is solely on a specific pair of starting and goal positions, rather than learning about the entire space. In such cases, the Rapidly Exploring Random Trees(RRT) can be used to construct the path. RRT dynamically explores the configuration space by incrementally building a tree-like structure from a random starting point. It rapidly expands the tree towards unexplored regions, continuously growing and adapting its branches based on sampled points and their connections. This exploration strategy allows RRT to efficiently generate feasible paths that connect a given starting point to an end goal.\nRepeat n times: Randomly sample a point x in the configuration space if x is in free space: Find the point y that closest to x if (Dist(x,y)\u003edelta) find z along the path from x to y such that Dist(z,y) \u003c= delta set x = z if the connection from x to each point is a free path add x to the tree with y as parent The key idea of the RRT algorithm is to add a point in a random direction and connect it to the closest point in the current tree during every iteration. Thus we expand the tree as much as possible and discover the path from starting point to the goal. In this assignment, we will implement the RPM and RRT for the six-link robot arm.\nSince we only sampling points a finite amount of times, the solution is not guaranteed to be optimal. In the figure below, we can observe that the trajectory generated by the RRT algorithm may differ between two runs.\nWhile the RRT algorithm may not provide an optimal solution, it remains valuable in motion planning tasks where finding an exact solution or optimality is not the primary objective. The algorithm strikes a balance between exploration and computational efficiency, making it well-suited for real-time applications where quick and reasonable solutions are desired.\nArtificial Potential Field Methods The artificial potential field method is another approach can be used to guide robots through obstacle environments. The method involves constructing a smooth function over the configuration space as attractive field. The function is designed to have its lowest value at the desired goal location, increasing as the robot moves away. By using the gradient of this function, the robot can be guided towards the goal configuration. Additionally, a repulsive potential field is constructed to steer the robot away from obstacles, based on the distance between the robot and the nearest obstacle. These attractive and repulsive potentials are combined to create a potential function that guides the robot while avoiding obstacles. The gradient of the potential function is then used to determine the direction of motion for the robot.\nExample The example demonstrates the motion planning with artificial potential field in a 2D configuration space. The configuration space consists of obstacles represented by black areas, a starting position represented by a green circle, and a goal represented by a red circle. The artificial potential field method is applied to guide the robot from the starting position to the goal while avoiding the obstacles. The potential function is constructed to attract the robot towards the goal and repel it from the obstacles. By evaluating the gradient of the potential function, the robot can determine the direction of motion and navigate towards the goal while circumventing the obstacles.\nConfiguration Space Given the starting and goal position, we can construct the attractive potential field. Then the repulsive potential field can be constructed with the obstacle in the configuration space. The two potential fields are shown below.\nThen the overall potential field can be constructed by simply adding those two. We can depict the path planning on the potential field as a descending process. In the figure below, the red ball represents the current position of the robot, which follows the gradient of the field towards the goal. The solution path is illustrated in the quiver plot depicted below. Quiver plots use arrows to represent vectors. In this case, the arrows indicate the direction of the gradient field at different locations in the configuration space, showing the path that the robot follows from the starting position to the goal.\nLimitation and Generalization Issues with Local Minimum\nSometimes, the potential field method can encounter local minima, where it gets stuck and fails to find the correct solution. In such situations, it may be necessary to employ heuristics to identify these cases and switch to alternative methods for motion planning.\nGeneralization\nOne way to extend the potential field method to higher dimensions, such as for robots with multiple degrees of freedom, is to consider it as a collection of control points. In the case of a six-link robot arm problem, we can view each joint as a control point and construct a potential field for each control point with respect to its respective goal.\nBy assigning potential fields to the control points corresponding to the desired goal positions of each joint, we can guide the robot arm towards its overall goal configuration. This generalization allows the potential field method to be applicable to higher-dimensional systems, providing a framework for planning and controlling robots with multiple degrees of freedom.\n(Images and codes are from Robotics: Computational Motion Planning.)\n","wordCount":"2357","inLanguage":"en","image":"https://ziwei-jiang.github.io/projects/robotics_specialization/computational_motion_planning/projects/robotics_specialization/imgs/course2/motion_planning.png","datePublished":"2016-03-15T11:30:03Z","dateModified":"2016-03-15T11:30:03Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://ziwei-jiang.github.io/projects/robotics_specialization/computational_motion_planning/"},"publisher":{"@type":"Organization","name":"Ziwei's Site","logo":{"@type":"ImageObject","url":"https://ziwei-jiang.github.io/img/abra_icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ziwei-jiang.github.io/ accesskey=h title="Ziwei Jiang 姜子维 (Alt + H)"><img src=https://ziwei-jiang.github.io/img/abra_icon.png alt aria-label=logo height=35>Ziwei Jiang 姜子维</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ziwei-jiang.github.io/about/ title=About><span>About</span></a></li><li><a href=https://ziwei-jiang.github.io/notes/ title=Notes><span>Notes</span></a></li><li><a href=https://ziwei-jiang.github.io/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://ziwei-jiang.github.io/publications/ title=Publications><span>Publications</span></a></li><li><a href=https://ziwei-jiang.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Robotics Specialization: Computational Motion Planning</h1><div class=post-description>Motion and path planning for robots.</div><div class=post-meta><span title='2016-03-15 11:30:03 +0000 +0000'>March 15, 2016</span>&nbsp;·&nbsp;&nbsp;·&nbsp;<a href=/tags/robotics> Robotics</a></div></header><figure class=entry-cover1><img loading=lazy src=https://ziwei-jiang.github.io/projects/robotics_specialization/imgs/course2/motion_planning.png alt><p></p></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#graph-based-methods aria-label="Graph-based Methods">Graph-based Methods</a><ul><li><a href=#dijkstra-algorithm aria-label="Dijkstra Algorithm">Dijkstra Algorithm</a></li><li><a href=#a-star-algorithm aria-label="A-Star Algorithm">A-Star Algorithm</a></li></ul></li><li><a href=#configuration-space-path-planning aria-label="Configuration Space Path Planning">Configuration Space Path Planning</a><ul><li><a href=#sampling-methods aria-label="Sampling Methods">Sampling Methods</a></li><li><a href=#motion-planning-in-free-space aria-label="Motion Planning in Free Space">Motion Planning in Free Space</a></li></ul></li><li><a href=#sampling-based-methods aria-label="Sampling-based Methods">Sampling-based Methods</a><ul><li><a href=#probabilistic-road-maps aria-label="Probabilistic Road Maps">Probabilistic Road Maps</a></li><li><a href=#rapidly-exploring-random-trees aria-label="Rapidly Exploring Random Trees">Rapidly Exploring Random Trees</a></li></ul></li><li><a href=#artificial-potential-field-methods aria-label="Artificial Potential Field Methods">Artificial Potential Field Methods</a><ul><li><a href=#example aria-label=Example>Example</a></li><li><a href=#limitation-and-generalization aria-label="Limitation and Generalization">Limitation and Generalization</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>Here are the assignments for the <em>Robotics Specialization: Computational Motion Planning</em> offered by UPenn on Coursera.</p><p>This is the second course in the robotics specialization. Throughout this course, we have gained knowledge on different techniques for planning robot motions. These include graph-based methods, randomized planners, and artificial potential fields.</p><h1 id=graph-based-methods>Graph-based Methods<a hidden class=anchor aria-hidden=true href=#graph-based-methods>#</a></h1><p>Graph-based methods tackle the challenge of planning routes for robots in environments with discrete positions, such as grids. To address this problem, we can represent such scenarios as graphs, where nodes signify grid locations, and edges indicate the routes between neighboring grid cells. In this course, we learned and implemented two graph-based algorithms, Dijkstra and the A-Star algorithm.</p><h2 id=dijkstra-algorithm>Dijkstra Algorithm<a hidden class=anchor aria-hidden=true href=#dijkstra-algorithm>#</a></h2><p>Dijkstra algorithm is a greedy algorithm for finding shortest path in weighted graphs. Invented by Dutch computer scientist Edsger W. Dijkstra in 1956, Dijkstra&rsquo;s algorithm has a wide range of applications in computer science, from network routing protocols to GPS nevigation. The algorithm works by exploring all possible paths from a starting node to a target node, keeping track of the distance traveled along each path. It then selects the shortest path and marks it as the optimal route. Here is a pseudocode for the Dijkstra algorithm.</p><pre><code>start_node start
for each node v:
    v.dist = infinity
start.dist = 0
list = [start]
while list is not empty:
    current = node in list with smallest distance
    list.del(current)
    for n in current.neighbor:
        if n.dist &gt; current.dist + dist(n, current):
            n.dist = current.dist + dist(n, current)
            n.parent = current
            if n not in list:
                list.append(n) 
</code></pre><p>When the algorithm visits a node, it updates the distances to its neighbors based on the shortest path found so far. Since any new paths to the neighbors would have to go through the current node, the loop invariant is true after updating the distances to its neighbors. When the algorithm terminates, all nodes in the graph have been visited and the loop invariant holds for all nodes. Therefore, the algorithm has found the shortest path from the start node to all other nodes in the graph. With naive implementation, the Dijkstra algorithm has time complexity $\mathcal{O}(|V|^2)$. Using priority queue, this can be reduced to $\mathcal{O}((|V|+|E|)\log(|V|))$.</p><p>Belowing is a demo result of Dijkstra algorithm implemented in Matlab. The green and yellow block are the start and target position. The blue blocks are the nodes in the list. The red blocks are the nodes with the shortest path have been found and removed from the list.<figure class=align-center><img loading=lazy src=/projects/robotics_specialization/imgs/course2/dijkstra.gif#center width=70%><figcaption>Dijkstra Algorithm</figcaption></figure></p><p>The Dijkstra algorithm can be computationally expensive on large graphs. Since the algorithm treats all nodes equally and does not consider any heuristic information about the target node, it may explore unnecessary paths. This makes it less suitable for real-time applications.</p><h2 id=a-star-algorithm>A-Star Algorithm<a hidden class=anchor aria-hidden=true href=#a-star-algorithm>#</a></h2><p>To overcome these limitations, the A-Star algorithm was developed by Peter Hart, Nils Nilsson and Bertram Raphael of Stanford Research Institute in 1968.
A-Star algorithm enhances Dijkstra&rsquo;s algorithm by introducing a heuristic function, which provides an estimate of the remaining distance from a particular node to the target node.</p><p>The heuristic function needs to satisfy the two criteria:</p><ul><li>$H(goal) = 0$</li><li>For any $x,y\in V$, $H(x)\leq H(y) + d(x,y)$</li></ul><p>By those two properties, for any node $v\in V$, we have
$$H(v) \leq \text{length of shortest path from v to goal}$$
So the heuristic function $H(v)$ is an underestimate for the distance between the node $v$ and the goal. With the heuristic function, the algorithm chooses the node that is most likely to be on the shortest path between start and goal node.</p><p>Here is a pseudocode for the A-Star algorithm.</p><pre><code>start_node start, goal_node goal
for each node v:
    v.dist = infinity, v.f = infinity
start.dist = 0, start.f = H(start)
list = [start]
while list is not empty:
    current = node in list with smallest f value
    list.del(current)
    if current == goal:
        return success
    for n in current.neighbor:
        if n.dist &gt; current.dist + dist(n, current):
            n.dist = current.dist + dist(n, current)
            n.f = n.g+H(n)
            n.parent = current
            if n not in list:
                list.append(n) 
</code></pre><p>Belowing is a demo result of A-Star algorithm implemented in Matlab.<figure class=align-center><img loading=lazy src=/projects/robotics_specialization/imgs/course2/a_star.gif#center width=70%><figcaption>Dijkstra Algorithm</figcaption></figure></p><h1 id=configuration-space-path-planning>Configuration Space Path Planning<a hidden class=anchor aria-hidden=true href=#configuration-space-path-planning>#</a></h1><p>Motion planning in <strong>configuration space</strong>, often referred to as C-space, involves utilizing the C-space as a representation of the feasible motions available to a robot. The configuration space encapsulates all the possible configurations of the robot, including the positions and orientations of its individual components. In configuration space planning, this graph is created directly in the C-space, where each node corresponds to a valid robot configuration and edges represent feasible transitions between them. By navigating this graph, motion planning algorithms can explore the C-space to find collision-free paths for the robot, accounting for its kinematic and dynamic constraints.</p><p>For instance, in the case of a two-linked arm, the configuration space would capture all possible combinations of joint angles, allowing the planner to find optimal paths while avoiding collisions. Similarly, in the piano mover&rsquo;s problem, where a robot needs to navigate through a cluttered environment to move a large object, configuration space planning enables the robot to consider the dimensions and orientations of both the robot and the object, resulting in more precise and accurate path planning. By leveraging the configuration space approach, motion planners can tackle a wide range of challenging scenarios, providing efficient and safe solutions for various robotic applications.</p><h2 id=sampling-methods>Sampling Methods<a hidden class=anchor aria-hidden=true href=#sampling-methods>#</a></h2><p>In this assignment, we worked with a two-link robot arm and its configuration space. Our goal was to guide the robot arm from one configuration to another while avoiding obstacles in the workspace. We applied <em>collision detection</em> by representing the robot arm and obstacles as collections of triangles. We checked for intersections between these triangles, allowing us to determine if the robot arm would collide with any obstacles while navigating the workspace.
In this example, the workspace and configuration space are shown in the following figure.<figure class=align-center><img loading=lazy src=/projects/robotics_specialization/imgs/course2/cspace.png#center width=100%><figcaption>Two link robot arm and its configuration space</figcaption></figure></p><p>We used a freespace sampling method, where we sampled points in the 2-dimensional configuration space and determined whether they were in free space or obstacle space based on the results of the collision check. This allowed us to represent the configuration space obstacles and free space with 2D array and apply the Dijkstra algorithm on torus.</p><h2 id=motion-planning-in-free-space>Motion Planning in Free Space<a hidden class=anchor aria-hidden=true href=#motion-planning-in-free-space>#</a></h2><p>The Dijkstra&rsquo;s algorithm can be slow in this case, particularly when dealing with a high-dimensional configuration space. To address this, we can employ the A-Star algorithm, which offers a more efficient alternative. The benefits of using the A-Star algorithm, compared to Dijkstra&rsquo;s algorithm, are illustrated in the figure below.</p><table><thead><tr><th style=text-align:center><img alt="Dijkstra Algorithm" loading=lazy src=/projects/robotics_specialization/imgs/course2/dijkstra_cspace.gif></th><th style=text-align:center><img alt="A-Star Algorithm" loading=lazy src=/projects/robotics_specialization/imgs/course2/astar_cspace.gif></th></tr></thead><tbody></tbody></table><p>After finding the shortest path in the configuration space, the robot can proceed to execute the corresponding trajectory.</p><table><thead><tr><th style=text-align:center><img loading=lazy src=/projects/robotics_specialization/imgs/course2/astar_traj.gif></th><th style=text-align:center><img loading=lazy src=/projects/robotics_specialization/imgs/course2/astar_arm.gif></th></tr></thead><tbody></tbody></table><h1 id=sampling-based-methods>Sampling-based Methods<a hidden class=anchor aria-hidden=true href=#sampling-based-methods>#</a></h1><h2 id=probabilistic-road-maps>Probabilistic Road Maps<a hidden class=anchor aria-hidden=true href=#probabilistic-road-maps>#</a></h2><p>In the above example, we employ a simple approach of evenly discretizing the continuous configuration space and utilizing a graph-based method to determine the shortest path. However, both the Dijkstra and A-Star algorithms can become slow when dealing with a large searching dimension. This situation often arises in scenarios where the configuration space exhibits a high dimensionality. To address this challenge, an alternative method is by selecting points randomly from the configuration space instead of uniformly. By using a subset of these randomly sampled points to represent the free space, we can effectively compute the shortest path. This technique is commonly referred to as <strong>Probabilistic Road Maps(PRM)</strong>. During each iteration of the algorithm, if the randomly sampled point falls in free space, we find k-nearest points according to some <em>distance function</em>. We then try to connect the sampled point to those points using a <em>local planner</em>, which checks if the line between two points is in free space. The pseudocode for the PRM algorithm is outlined below.</p><pre><code>Repeat n times:
    Randomly sample a point x in the configuration space
    if x is in free space:
        Find the k closest points to x according to the distance function
        Form a new edge if the connection from x to each point is a free path
</code></pre><p>Although sampling-based methods are often effective in practice, it&rsquo;s important to note that these algorithms are not considered complete. This means that there is a possibility of the algorithm failing to find a path, even if one exists. But we can say that as we continue sampling new points, the algorithm will eventually find a solution if a path to the goal exists. In other word, as the number of samples (n) approaches infinity, the probability of not finding a path approaches zero. This is known as <strong>probabilistically complete</strong>.</p><p>However, this process could take a very long time in some cases. For instance, if we there is a narrow pathway to the goal, the algorithm will require a denser sampling to successfully discover the solution.</p><table><thead><tr><th style=text-align:center><img loading=lazy src=/projects/robotics_specialization/imgs/course2/twisty_passageway_1.png></th><th style=text-align:center><img loading=lazy src=/projects/robotics_specialization/imgs/course2/twisty_passageway_2.png></th></tr></thead><tbody></tbody></table><h2 id=rapidly-exploring-random-trees>Rapidly Exploring Random Trees<a hidden class=anchor aria-hidden=true href=#rapidly-exploring-random-trees>#</a></h2><p>The Probabilistic Roadmap (PRM) algorithm offers the advantage of constructing a structure that represents the entire configuration space, allowing for easy adaptation to different starting and ending positions. However, there are scenarios where our focus is solely on a specific pair of starting and goal positions, rather than learning about the entire space. In such cases, the <strong>Rapidly Exploring Random Trees(RRT)</strong> can be used to construct the path. RRT dynamically explores the configuration space by incrementally building a tree-like structure from a random starting point. It rapidly expands the tree towards unexplored regions, continuously growing and adapting its branches based on sampled points and their connections. This exploration strategy allows RRT to efficiently generate feasible paths that connect a given starting point to an end goal.</p><pre><code>Repeat n times:
    Randomly sample a point x in the configuration space
    if x is in free space:
        Find the point y that closest to x
        if (Dist(x,y)&gt;delta)
            find z along the path from x to y such that Dist(z,y) &lt;= delta
            set x = z
        if the connection from x to each point is a free path
            add x to the tree with y as parent
</code></pre><p>The key idea of the RRT algorithm is to add a point in a random direction and connect it to the closest point in the current tree during every iteration. Thus we expand the tree as much as possible and discover the path from starting point to the goal. In this assignment, we will implement the RPM and RRT for the six-link robot arm.</p><p>Since we only sampling points a finite amount of times, the solution is not guaranteed to be optimal. In the figure below, we can observe that the trajectory generated by the RRT algorithm may differ between two runs.</p><table><thead><tr><th style=text-align:center><img loading=lazy src=/projects/robotics_specialization/imgs/course2/rpm1.gif></th><th style=text-align:center><img loading=lazy src=/projects/robotics_specialization/imgs/course2/rpm2.gif></th></tr></thead><tbody></tbody></table><p>While the RRT algorithm may not provide an optimal solution, it remains valuable in motion planning tasks where finding an exact solution or optimality is not the primary objective. The algorithm strikes a balance between exploration and computational efficiency, making it well-suited for real-time applications where quick and reasonable solutions are desired.</p><h1 id=artificial-potential-field-methods>Artificial Potential Field Methods<a hidden class=anchor aria-hidden=true href=#artificial-potential-field-methods>#</a></h1><p>The artificial potential field method is another approach can be used to guide robots through obstacle environments. The method involves constructing a smooth function over the configuration space as attractive field. The function is designed to have its lowest value at the desired goal location, increasing as the robot moves away. By using the gradient of this function, the robot can be guided towards the goal configuration. Additionally, a repulsive potential field is constructed to steer the robot away from obstacles, based on the distance between the robot and the nearest obstacle. These attractive and repulsive potentials are combined to create a potential function that guides the robot while avoiding obstacles. The gradient of the potential function is then used to determine the direction of motion for the robot.</p><h2 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h2><p>The example demonstrates the motion planning with artificial potential field in a 2D configuration space. The configuration space consists of obstacles represented by black areas, a starting position represented by a green circle, and a goal represented by a red circle. The artificial potential field method is applied to guide the robot from the starting position to the goal while avoiding the obstacles. The potential function is constructed to attract the robot towards the goal and repel it from the obstacles. By evaluating the gradient of the potential function, the robot can determine the direction of motion and navigate towards the goal while circumventing the obstacles.</p><figure class=align-center><img loading=lazy src=/projects/robotics_specialization/imgs/course2/config_space.png#center width=70%><figcaption>Configuration Space</figcaption></figure><p>Given the starting and goal position, we can construct the attractive potential field. Then the repulsive potential field can be constructed with the obstacle in the configuration space. The two potential fields are shown below.</p><table><thead><tr><th style=text-align:center><img loading=lazy src=/projects/robotics_specialization/imgs/course2/attractive_potential.png></th><th style=text-align:center><img loading=lazy src=/projects/robotics_specialization/imgs/course2/repulsive_potential.png></th></tr></thead><tbody></tbody></table><p>Then the overall potential field can be constructed by simply adding those two.<figure class=align-center><img loading=lazy src=/projects/robotics_specialization/imgs/course2/total_potential.png#center width=70%></figure></p><p>We can depict the path planning on the potential field as a descending process. In the figure below, the red ball represents the current position of the robot, which follows the gradient of the field towards the goal.<figure class=align-center><img loading=lazy src=/projects/robotics_specialization/imgs/course2/potential_field.gif#center width=70%></figure></p><p>The solution path is illustrated in the quiver plot depicted below. Quiver plots use arrows to represent vectors. In this case, the arrows indicate the direction of the gradient field at different locations in the configuration space, showing the path that the robot follows from the starting position to the goal.</p><figure class=align-center><img loading=lazy src=/projects/robotics_specialization/imgs/course2/quiver_plot.png#center width=70%></figure><h2 id=limitation-and-generalization>Limitation and Generalization<a hidden class=anchor aria-hidden=true href=#limitation-and-generalization>#</a></h2><p><strong>Issues with Local Minimum</strong></p><p>Sometimes, the potential field method can encounter local minima, where it gets stuck and fails to find the correct solution. In such situations, it may be necessary to employ heuristics to identify these cases and switch to alternative methods for motion planning.</p><p><strong>Generalization</strong></p><p>One way to extend the potential field method to higher dimensions, such as for robots with multiple degrees of freedom, is to consider it as a collection of control points. In the case of a six-link robot arm problem, we can view each joint as a control point and construct a potential field for each control point with respect to its respective goal.</p><p>By assigning potential fields to the control points corresponding to the desired goal positions of each joint, we can guide the robot arm towards its overall goal configuration. This generalization allows the potential field method to be applicable to higher-dimensional systems, providing a framework for planning and controlling robots with multiple degrees of freedom.</p><p>(Images and codes are from <a href=https://www.coursera.org/learn/robotics-motion-planning/home/>Robotics: Computational Motion Planning</a>.)</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ziwei-jiang.github.io/tags/robotics/>Robotics</a></li></ul><nav class=paginav><a class=prev href=https://ziwei-jiang.github.io/projects/robotics_specialization/perception/><span class=title>« Prev</span><br><span>Robotics Specialization: Perception</span>
</a><a class=next href=https://ziwei-jiang.github.io/projects/robotics_specialization/aerial_robotics/><span class=title>Next »</span><br><span>Robotics Specialization: Aerial Robotics</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ziwei-jiang.github.io/>Ziwei's Site</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>